# Batch Rendering System in BlockConnection

BlockConnection uses a sophisticated batch rendering system to optimize performance when displaying many connections. Instead of drawing each connection individually, the system groups connections with similar visual properties and renders them together, significantly reducing canvas API calls.

## How Batching Works

When a BlockConnection is created, it registers itself with the batch renderer:

```typescript
// In BlockConnection constructor
this.context.batch.add(this, { 
  zIndex: this.zIndex, 
  group: this.getClassName() 
});
```

The `group` parameter is key to batching efficiency. It's generated by `getClassName()` method which creates a unique identifier based on the connection's visual state:

```typescript
// Example group names:
"connection/none/none/#4285f4/"           // Normal connection
"connection/hovered/none/#4285f4/"        // Hovered connection  
"connection/none/selected/#1976d2/"       // Selected connection
"connection/none/none/#ff6b6b/8,4"        // Dashed connection
```

Connections with identical group names are batched together - they share the same canvas context state (color, line width, dash pattern) and are drawn in a single operation.

## Batch Management Methods

The batch system provides three main methods for managing connections:

**`add(connection, params)`** - Registers a new connection with the batch renderer:
```typescript
this.context.batch.add(this, { zIndex: 10, group: "connection/none/none/#4285f4/" });
```

**`update(connection, params)`** - Updates connection parameters or adds if not present:
```typescript
// Changes group when connection state changes (hover, selection)
this.context.batch.update(this, { zIndex: 20, group: "connection/hovered/none/#4285f4/" });
```

**`delete(connection)`** - Removes connection from batch renderer:
```typescript
// Called when connection is destroyed
this.context.batch.delete(this);
```

## Automatic State Management

BlockConnection automatically manages its batch state through the `applyShape()` method, which is called whenever the connection's visual state changes:

```typescript
protected applyShape(state, props) {
  const zIndex = state.selected || state.hovered ? this.zIndex + 10 : this.zIndex;
  
  // Update main connection
  this.context.batch.update(this, { 
    zIndex: zIndex, 
    group: this.getClassName(state) 
  });
  
  // Handle arrow batching
  if (props.showConnectionArrows) {
    this.context.batch.update(this.arrowShape, { 
      zIndex: zIndex, 
      group: `arrow/${this.getClassName(state)}` 
    });
  } else {
    this.context.batch.delete(this.arrowShape);
  }
}
```

This system ensures that:
- Connections are automatically re-batched when their appearance changes
- Z-index ordering is maintained (selected/hovered connections appear on top)
- Arrows are managed separately from their parent connections
- Memory is cleaned up when connections are destroyed

## Performance Benefits

The batch rendering system provides significant performance improvements:
- **Reduced Draw Calls**: Hundreds of similar connections are drawn in single operations
- **Efficient State Changes**: Canvas context (colors, line styles) is set once per group
- **Automatic Optimization**: No manual performance tuning required
- **Scalability**: Handles thousands of connections smoothly

## Integration in Custom Connections

When extending BlockConnection, the batch system works automatically. However, if you need to customize batching behavior:

### Custom Group Names

Override `getClassName()` to create custom batching groups:

```typescript
class MyCustomConnection extends BlockConnection {
  public getClassName(state = this.state) {
    // Add custom properties to the group name
    const priority = state.priority || "normal";
    const base = super.getClassName(state);
    return `${base}/${priority}`;
  }
}
```

### Manual Batch Management

For advanced cases, manually manage batch registration:

```typescript
class AdvancedConnection extends BlockConnection {
  protected customBatchGroup() {
    // Remove from current batch
    this.context.batch.delete(this);
    
    // Add to custom batch group
    this.context.batch.add(this, { 
      zIndex: this.zIndex, 
      group: "custom-connection-type"
    });
  }
}
```

### Best Practices

1. **Minimize Group Variations**: Too many unique groups reduce batching efficiency
2. **Use Consistent Naming**: Follow the pattern `type/state/color/pattern`
3. **Clean Up Properly**: Always call `delete()` in unmount methods
4. **Leverage Inheritance**: Extend existing `applyShape()` rather than replacing it

## Troubleshooting

### Performance Issues

If you notice performance problems with custom connections:

1. Check group name uniqueness - too many unique groups prevent batching
2. Verify `applyShape()` is called appropriately on state changes
3. Ensure proper cleanup in unmount methods

### Visual Artifacts

If connections render incorrectly:

1. Verify the `style()` method sets correct canvas context
2. Check that `getPath()` returns valid Path2D objects
3. Ensure Z-index values are appropriate for layering
